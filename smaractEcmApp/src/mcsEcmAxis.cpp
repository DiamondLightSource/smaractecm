/*
 * mcsEcmAxis.cpp
 *
 *  Created on: Apr 2016
 *      Author: hgv27681
 */

/*
 * NOTE :
 * It is necessary to use the
 * 		setDoubleParam(controller->motorPosition_, (double)curPosition);
 * form to set certain parameters rather than the asynaid form:
 * 		controller->paramMotorMotorPosition[axisNum] = (double)curPosition;
 * This is because asynaid does not currently handle arrays of parameters well.
 */

#include "mcsEcmAxis.h"

#include <stdlib.h>
#include <iostream>
#include "ecmController.h"
#include <epicsThread.h>
#include "FreeLock.h"

/** Constructor
 * \param[in] portName Asyn port name
 */
McsEcmAxis::McsEcmAxis(EcmController* ctlr, int axisNum, bool rotary)
: SmaractAxis(ctlr, axisNum)
, rotary(rotary)
, pollPhase(POLLPHASE0)
{
}

/** Destructor
 */
McsEcmAxis::~McsEcmAxis()
{
}

/** Move axis command. Entered with the lock taken.
 * \param[in] position Where to move to
 * \param[in] relative Non-zero for a relative move
 * \param[in] minVelocity The minimum velocity during the move
 * \param[in] maxVelocity The maximum velocity during the move
 * \param[in] acceleration The acceleration to use
 */
asynStatus McsEcmAxis::move(double position, int relative,
        double minVelocity, double maxVelocity, double acceleration)
{
	// If axis not connected to a physical address, do nothing
	if(!isConnected()) return asynSuccess;

	TakeLock takeLock(controller, /*alreadyTaken=*/true);
    // Start the move
    //// int a;
    //// int b;
    // Get information
    //int activeHold = controller->paramActiveHold[axisNum];
    FreeLock freeLock(takeLock);

    // Perform the move
    // controller->command("SCLS", physicalAxis(), (int)maxVelocity, "E", &a, &b);
    if(relative)
    {
        if(rotary)
        {
            // controller->command("MAR", physicalAxis(), (int)position, 0, 60000*activeHold, "E", &a, &b);
        }
        else
        {
            // controller->command("MPR", physicalAxis(), (int)position, 60000*activeHold, "E", &a, &b);
        }
    }
    else
    {
        if(rotary)
        {
            // In rotary mode, we must always send an angle between 0 and 360.  An angle
            // outside this range must be converted to a revolution number and an angle
            int targetRevolution = (int)position / 360000000;
            int targetPosition = (int)position % 360000000;
            if(targetPosition < 0)
            {
                targetPosition += 360000000;
                targetRevolution -= 1;
            }
            // controller->command("MAA", physicalAxis(), targetPosition, targetRevolution, 60000*activeHold, "E", &a, &b);
        }
        else
        {
            // controller->command("MPA", physicalAxis(), (int)position, 60000*activeHold, "E", &a, &b);
        }
    }
    {
    	TakeLock again(freeLock);
        setIntegerParam(controller->motorStatusDone_, 0);
        setIntegerParam(controller->motorStatusMoving_, 1);
        setIntegerParam(controller->motorStatusDirection_, (int)position > curPosition);

    }

    // Wait for move to complete.  
    int status = 0;
    bool moving = true;
    while(moving /* && controller->command("GS", physicalAxis(), "S", &a, &status)*/)
    {
        moving = !(status == 3 || status == 0);
    }

    // Do a poll now
    pollStatus(freeLock);
    return asynSuccess;
}

/** Get status from the controller that does not change.
  */
bool McsEcmAxis::onceOnlyStatus(FreeLock& freeLock)
{
	// If axis not connected to a physical address, do nothing
	if(!isConnected()) return asynSuccess;

    bool result = true;
    // int a;

    // Put the axis in debug mode so we can see the sine and cosine parameters
    result = false; // && // controller->command("ED", physicalAxis(), 1, "E", &a);
    if(result)
    {
    	TakeLock takeLock(freeLock);
        setIntegerParam(controller->motorStatusHighLimit_, 0);
        setIntegerParam(controller->motorStatusLowLimit_, 0);
        setIntegerParam(controller->motorStatusHasEncoder_, 0);
        setDoubleParam(controller->motorVelocity_, 0.0);
        setIntegerParam(controller->motorStatusSlip_, 0);
        setIntegerParam(controller->motorStatusCommsError_, 0);
        setIntegerParam(controller->motorStatusFollowingError_, 0);
        setIntegerParam(controller->motorStatusProblem_, 0);
    }
    return result;
}

/** Get status from the controller that needs polling frequently.
 *  We need to minimise the amount of traffic generated by the poll,
 *  so the less important parameters are only polled once in three.
 */
bool McsEcmAxis::pollStatus(FreeLock& freeLock)
{
	// If axis not connected to a physical address, do nothing
	if(!isConnected()) return false;

    bool result = true;
    int curPosition;
    int revolution;
    int homeStatus;
    int status;
    int cosine;
    int sine;
    // int a;
    // int b;

    if(rotary)
    {
        result = false; // && // controller->command("GA", physicalAxis(), "A", &a, &curPosition, &revolution);
        curPosition = curPosition + 360000000*revolution;
    }
    else
    {
        result = false; // && // controller->command("GP", physicalAxis(), "P", &a, &curPosition);
    }
    result = false; // && // controller->command("GS", physicalAxis(), "S", &a, &status);
    switch(pollPhase)
    {
    case POLLPHASE0:
        result = false; // && // controller->command("RDV", physicalAxis(), 22, "DP", &a, &b, &cosine);
        break;
    case POLLPHASE1:
        result = false; // && // controller->command("RDV", physicalAxis(), 23, "DP", &a, &b, &sine);
        break;
    case POLLPHASE2:
        result = false; // && // controller->command("GPPK", physicalAxis(), "PPK", &a, &homeStatus);
        break;
    }
    if(result)
    {
    	TakeLock takeLock(freeLock);
        setDoubleParam(controller->motorEncoderPosition_, (double)curPosition);
        setDoubleParam(controller->motorPosition_, (double)curPosition);
        setIntegerParam(controller->motorStatusDone_, status == 3 || status == 0);
        setIntegerParam(controller->motorStatusMoving_, !(status == 3 || status == 0));

        switch(pollPhase)
        {
        case POLLPHASE0:
            controller->paramCosine[axisNum] = cosine;
            break;
        case POLLPHASE1:
            controller->paramSine[axisNum] = sine;
            break;
        case POLLPHASE2:
            controller->paramMotorStatusHomed[axisNum] = homeStatus != 0;
            break;
        }

        this->callParamCallbacks();
    }
    switch(pollPhase)
    {
    case POLLPHASE0:
        pollPhase = POLLPHASE1;
        break;
    case POLLPHASE1:
        pollPhase = POLLPHASE2;
        break;
    case POLLPHASE2:
        pollPhase = POLLPHASE0;
        break;
    default:
        pollPhase = POLLPHASE0;
        break;
    }
    return result;
}

/** Jog axis command
 * \param[in] minVelocity The minimum velocity during the move
 * \param[in] maxVelocity The maximum velocity during the move
 * \param[in] acceleration The acceleration to use
 */
asynStatus McsEcmAxis::moveVelocity(double minVelocity,
        double maxVelocity, double acceleration)
{
    return asynSuccess;
}

/** Home axis command.  Entered with the lock taken
 * \param[in] minVelocity The minimum velocity during the move
 * \param[in] maxVelocity The maximum velocity during the move
 * \param[in] acceleration The acceleration to use
 * \param[in] forwards Set to TRUE to home forwards
 */
asynStatus McsEcmAxis::home(double minVelocity, double maxVelocity,
        double acceleration, int forwards)
{
	// If axis not connected to a physical address, do nothing
	if(!isConnected()) return asynSuccess;

	TakeLock takeLock(controller, /*alreadyTake=*/true);
    // int a;
    // int b;

    // Get information
    // int activeHold = controller->paramActiveHold[axisNum];

    setIntegerParam(controller->motorStatusDone_, 0);
    setIntegerParam(controller->motorStatusMoving_, 1);
    setIntegerParam(controller->motorStatusDirection_, forwards);

    // Perform the move
    FreeLock freeLock(takeLock);
    // controller->command("SCLS", physicalAxis(), (int)maxVelocity, "E", &a, &b);
    // controller->command("FRM", physicalAxis(), forwards?0:1, 60000*activeHold, 1, "E", &a, &b);
    
    // Wait for move to complete.  
    int status = 0;
    bool moving = true;
    while(moving  /*&& controller->command("GS", physicalAxis(), "S", &a, &status)*/ )
    {
        moving = !(status == 3 || status == 0);
    }

    // Do a poll now
    pollStatus(freeLock);
    return asynSuccess;
}

/** Stop axis command.  Entered with the lock taken.
 * \param[in] acceleration The acceleration to use
 */
asynStatus McsEcmAxis::stop(double acceleration)
{
	// If axis not connected to a physical address, do nothing
	if(!isConnected()) return asynSuccess;

	TakeLock takeLock(controller, /*alreadyTake=*/true);

    // int a;
    // controller->command("S", physicalAxis(), "E", &a);

    setIntegerParam(controller->motorStatusDone_, 1);
    setIntegerParam(controller->motorStatusMoving_, 0);

    return asynSuccess;
}

/** Set position command
 * \param[in] position The current position of the motor
 */
asynStatus McsEcmAxis::setPosition(double position)
{
	// If axis not connected to a physical address, do nothing
	if(!isConnected()) return asynSuccess;

    // int a;
    // int b;

    // controller->command("SP", physicalAxis(), (int)position, "E", &a, &b);
    return asynSuccess;
}

/** Calibrate the sensor attached to this channel.
 * \param[in] yes Controls whether calibration is performed
 */
void McsEcmAxis::calibrateSensor(TakeLock& takeLock, int yes)
{
	// If axis not connected to a physical address, do nothing
	if(!isConnected()) return;

    int oldYes = controller->paramCalibrateSensor[axisNum];
    if(oldYes == 0 && yes == 1)
    {
        // int a;
        // int b;
        // controller->command("CS", physicalAxis(), "E", &a, &b);
    }
}



